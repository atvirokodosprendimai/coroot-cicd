<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pipeline History â€” Coroot CI/CD</title>
<link rel="stylesheet" href="tufte.css"/>
<style>
  body { background-color: #151515; color: #ddd; }
  code { background: #1a1a1a; padding: 0.1em 0.3em; border-radius: 2px; }
  a { color: inherit; }
  table { border-top: 2px solid #666; border-bottom: 2px solid #666; }
  th { border-bottom: 1px solid #444; font-weight: normal; padding: 0.5em 0.6em; text-align: left; }
  td { padding: 0.4em 0.6em; border: none; }
  .result-success { color: #6a9; }
  .result-failure { color: #b66; }
  .result-skipped, .result-cancelled { color: #888; }
  svg.sparkline { display: inline-block; vertical-align: text-bottom; }
  svg.dag { display: block; margin: 1.4rem 0; }
  .dag text { font-family: et-book, Palatino, Georgia, serif; font-size: 11px; fill: #ccc; }
  .dag rect { fill: none; stroke: #888; stroke-width: 1; rx: 2; }
  .dag line, .dag path { stroke: #888; stroke-width: 1; fill: none; }
  .dag .conditional { stroke-dasharray: 4,3; }
  .dag .label-small { font-size: 9px; fill: #888; font-style: italic; }
  #runs-table { font-size: 0.95rem; }
  .no-data { color: #888; padding: 1rem 0; font-style: italic; }
  .meta { color: #888; font-size: 0.9rem; margin-top: 0.4rem; }
</style>
</head>
<body>
<article>

<h1>Pipeline History</h1>
<p class="subtitle"><a href="index.html">&larr; Coroot CI/CD</a></p>

<section>
<p><span class="newthought">The update pipeline</span> runs every Monday at 04:00 UTC
or on manual dispatch. It consists of six sequential jobs, each depending on the
previous.<label for="sn-data" class="margin-toggle sidenote-number"></label><input
type="checkbox" id="sn-data" class="margin-toggle"/><span class="sidenote">The data on this
page is pre-generated from the GitHub Actions API every six hours and on each pipeline
completion. No authentication or API token is needed to view it.</span></p>

<svg class="dag" viewBox="0 0 580 88" width="580" height="88" aria-label="Pipeline job flow diagram">
  <defs>
    <marker id="arr" viewBox="0 0 10 10" refX="9" refY="5"
            markerWidth="5" markerHeight="5" orient="auto">
      <path d="M 0 1 L 8 5 L 0 9 z" fill="#888"/>
    </marker>
  </defs>
  <g transform="translate(2,2)">
    <!-- Check -->
    <rect x="0" y="8" width="80" height="30"/>
    <text x="40" y="27" text-anchor="middle">Check</text>
    <line x1="80" y1="23" x2="96" y2="23" marker-end="url(#arr)"/>

    <!-- Backup -->
    <rect x="96" y="8" width="80" height="30"/>
    <text x="136" y="27" text-anchor="middle">Backup</text>
    <line x1="176" y1="23" x2="192" y2="23" marker-end="url(#arr)"/>

    <!-- Staging -->
    <rect x="192" y="8" width="80" height="30"/>
    <text x="232" y="27" text-anchor="middle">Staging</text>
    <line x1="272" y1="23" x2="288" y2="23" marker-end="url(#arr)"/>

    <!-- Deploy -->
    <rect x="288" y="8" width="80" height="30"/>
    <text x="328" y="27" text-anchor="middle">Deploy</text>
    <line x1="368" y1="23" x2="384" y2="23" marker-end="url(#arr)"/>

    <!-- Cleanup -->
    <rect x="384" y="8" width="80" height="30"/>
    <text x="424" y="27" text-anchor="middle">Cleanup</text>

    <!-- Deploy -> Rollback (conditional, downward) -->
    <line x1="328" y1="38" x2="328" y2="48" class="conditional" marker-end="url(#arr)"/>

    <!-- Rollback -->
    <rect x="288" y="48" width="80" height="30"/>
    <text x="328" y="67" text-anchor="middle">Rollback</text>
    <text x="374" y="62" class="label-small">on failure</text>

    <!-- Rollback -> Cleanup -->
    <path d="M 368 63 L 380 63 L 380 38 L 424 38" class="conditional" marker-end="url(#arr)"/>
  </g>
</svg>

<p>The first job compares running container image digests against the latest releases.
If no updates are found, the pipeline exits early unless <code>force_deploy</code> is set.
Otherwise it proceeds through backup, staging validation, production deployment, and
cleanup. The rollback job fires only when the deploy job itself fails&mdash;not when
staging fails or when the pipeline is cancelled.<label for="sn-rollback" class="margin-toggle sidenote-number"></label><input
type="checkbox" id="sn-rollback" class="margin-toggle"/><span class="sidenote">The trigger
condition is <code>always() && needs.deploy.result == 'failure'</code>. A naive
<code>if: failure()</code> would also fire when upstream jobs fail, causing unnecessary
rollbacks that touch production data when production is running fine.</span></p>
</section>

<section>
<h2>Recent Runs</h2>

<p><span class="newthought">The table below</span> shows recent workflow runs with
per-job timing.<label for="sn-sparkline" class="margin-toggle sidenote-number"></label><input
type="checkbox" id="sn-sparkline" class="margin-toggle"/><span class="sidenote">Each row
includes a small bar chart showing the relative duration of each job within that run.
Taller bars indicate longer-running jobs. Grey bars indicate skipped jobs. The bar order
matches the pipeline: Check, Backup, Staging, Deploy, Rollback, Cleanup.</span>
The data is loaded from a static JSON file updated automatically by a
<a href="https://github.com/atvirokodosprendimai/coroot-cicd/actions/workflows/update-docs-data.yml">GitHub Actions workflow</a>.</p>

<div id="runs-container">
  <table id="runs-table">
    <thead>
      <tr>
        <th>Run</th>
        <th>Date</th>
        <th>Trigger</th>
        <th>Result</th>
        <th>Duration</th>
        <th>Jobs</th>
      </tr>
    </thead>
    <tbody id="runs-body">
      <tr><td colspan="6" class="no-data">Loading&hellip;</td></tr>
    </tbody>
  </table>
</div>

<p class="meta" id="data-meta"></p>

</section>

</article>

<script>
(function () {
  const JOBS_ORDER = [
    'Check for Image Updates',
    'Backup Volumes',
    'Staging Validation',
    'Deploy to Production',
    'Rollback on Failure',
    'Post-Pipeline Cleanup'
  ];

  function jobDuration(job) {
    if (!job || !job.started_at || !job.completed_at) return 0;
    return Math.max(0, (new Date(job.completed_at) - new Date(job.started_at)) / 1000);
  }

  function formatDuration(s) {
    if (s <= 0) return '';
    var m = Math.floor(s / 60), sec = Math.round(s % 60);
    return m > 0 ? m + 'm ' + sec + 's' : sec + 's';
  }

  function triggerLabel(event) {
    if (event === 'schedule') return 'Scheduled';
    if (event === 'workflow_dispatch') return 'Manual';
    return event;
  }

  function resultClass(conclusion) {
    if (conclusion === 'success') return 'result-success';
    if (conclusion === 'failure') return 'result-failure';
    return 'result-skipped';
  }

  function sparkline(run) {
    var jobMap = {};
    (run.jobs || []).forEach(function (j) { jobMap[j.name] = j; });

    var durations = JOBS_ORDER.map(function (name) {
      var j = jobMap[name];
      return { dur: jobDuration(j), conclusion: j ? (j.conclusion || j.status) : 'skipped' };
    });

    var maxDur = Math.max.apply(null, durations.map(function (d) { return d.dur; }));
    if (maxDur <= 0) maxDur = 1;

    var barW = 7, gap = 3, h = 16;
    var totalW = durations.length * (barW + gap) - gap;
    var bars = durations.map(function (d, i) {
      var barH = Math.max(1, (d.dur / maxDur) * (h - 2));
      var color = (d.conclusion === 'success') ? '#6a9' :
                  (d.conclusion === 'failure') ? '#b66' : '#555';
      return '<rect x="' + (i * (barW + gap)) + '" y="' + (h - barH - 1) + '" width="' + barW + '" height="' + barH + '" fill="' + color + '"/>';
    }).join('');

    return '<svg class="sparkline" viewBox="0 0 ' + totalW + ' ' + h + '" width="' + totalW + '" height="' + h + '">' + bars + '</svg>';
  }

  function totalDuration(run) {
    if (!run.created_at || !run.updated_at) return 0;
    return (new Date(run.updated_at) - new Date(run.created_at)) / 1000;
  }

  function render(data) {
    var tbody = document.getElementById('runs-body');
    var runs = data.runs || [];

    if (runs.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" class="no-data">No pipeline runs found.</td></tr>';
      return;
    }

    tbody.innerHTML = runs.map(function (run) {
      var conclusion = run.conclusion || run.status;
      var date = new Date(run.created_at);
      var dur = totalDuration(run);
      return '<tr>' +
        '<td><a href="' + run.html_url + '">#' + run.run_number + '</a></td>' +
        '<td>' + date.toLocaleDateString() + '</td>' +
        '<td>' + triggerLabel(run.event) + '</td>' +
        '<td class="' + resultClass(conclusion) + '">' + conclusion + '</td>' +
        '<td>' + formatDuration(dur) + '</td>' +
        '<td>' + sparkline(run) + '</td>' +
        '</tr>';
    }).join('');

    // Data freshness note
    var meta = document.getElementById('data-meta');
    if (data.generated_at) {
      var gen = new Date(data.generated_at);
      meta.textContent = 'Data generated ' + gen.toLocaleDateString() + ' ' + gen.toLocaleTimeString();
    }
  }

  // Load pre-generated data
  fetch('data/pipeline-runs.json')
    .then(function (r) { return r.json(); })
    .then(render)
    .catch(function (e) {
      document.getElementById('runs-body').innerHTML =
        '<tr><td colspan="6" class="no-data">Could not load pipeline data.</td></tr>';
    });
})();
</script>
</body>
</html>
