<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pipeline Status â€” Coroot CI/CD</title>
<link rel="stylesheet" href="tufte.css"/>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { background-color: #151515; color: #ddd; }
  .controls {
    margin: 1.4rem 0;
    font-size: 1rem;
  }
  .controls input {
    font-family: et-book, Palatino, "Palatino Linotype", Georgia, serif;
    font-size: 1rem;
    background: #1a1a1a;
    border: 1px solid #333;
    color: #ddd;
    padding: 0.4rem 0.6rem;
    width: 22rem;
  }
  .controls button {
    font-family: et-book, Palatino, "Palatino Linotype", Georgia, serif;
    font-size: 1rem;
    background: none;
    border: 1px solid #333;
    color: #ddd;
    padding: 0.4rem 0.8rem;
    cursor: pointer;
  }
  .controls button:hover { border-color: #888; }
  .pipeline-container {
    background: #fffff8;
    padding: 1.5rem;
    border-radius: 2px;
    margin: 1.4rem 0;
  }
  svg { width: 100%; }
  .pipeline-node rect {
    rx: 2; ry: 2;
    stroke-width: 1;
  }
  .pipeline-node text {
    fill: #111;
    font-family: et-book, Palatino, Georgia, serif;
    font-size: 12px;
  }
  .pipeline-node .duration {
    fill: #888;
    font-size: 10px;
    font-style: italic;
  }
  .status-bar {
    margin: 0.8rem 0;
    font-size: 1rem;
    color: #999;
    line-height: 1.8;
  }
  .status-dot {
    width: 7px; height: 7px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 4px;
  }
  .status-dot.success, .status-dot.completed { background: #4a8c5c; }
  .status-dot.failure { background: #b55; }
  .status-dot.pending, .status-dot.queued, .status-dot.waiting { background: #a89040; }
  .status-dot.in_progress { background: #5580aa; animation: pulse 1.5s infinite; }
  .status-dot.skipped, .status-dot.cancelled { background: #888; }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.3} }
  .run-item {
    padding: 0.6rem 0;
    border-bottom: 1px solid #222;
    display: flex;
    align-items: center;
    gap: 1rem;
    cursor: pointer;
  }
  .run-item:hover { background: #1a1a1a; }
  .run-item.active { border-left: 2px solid #ddd; padding-left: 0.6rem; }
  .run-meta { flex: 1; }
  .run-meta .title { font-size: 1.1rem; }
  .run-meta .info { color: #888; font-size: 0.9rem; }
  .run-status {
    font-size: 0.85rem;
    font-variant: small-caps;
    letter-spacing: 0.05em;
  }
  .run-status.success, .run-status.completed { color: #4a8c5c; }
  .run-status.failure { color: #b55; }
  .run-status.in_progress { color: #5580aa; }
  .run-status.pending, .run-status.queued, .run-status.waiting { color: #a89040; }
  .run-status.cancelled, .run-status.skipped { color: #888; }
  .error-msg { color: #b55; margin: 1rem 0; font-style: italic; }
  .no-data { color: #888; padding: 2rem 0; }
</style>
</head>
<body>
<article>

<h1>Pipeline Status</h1>
<p class="subtitle"><a href="index.html">&larr; Coroot CI/CD</a></p>

<section>
<p><span class="newthought">This page shows</span> real-time data from the GitHub Actions
API.<label for="sn-token" class="margin-toggle sidenote-number"></label><input type="checkbox"
id="sn-token" class="margin-toggle"/><span class="sidenote">The token is stored only in your
browser's <code>localStorage</code>. It is never sent anywhere except the GitHub API. For
public repos, a token with no scopes suffices; for private repos, the <code>repo</code> scope
is needed.</span>
Enter a GitHub Personal Access Token to load workflow run history. The diagram updates
every thirty seconds.</p>

<div class="controls">
  <input type="password" id="token-input" placeholder="GitHub Personal Access Token">
  <button onclick="saveToken()">Save</button>
  <button onclick="fetchData()">Refresh</button>
</div>

<div class="status-bar" id="status-bar">
  <span id="last-updated">Not loaded</span>
</div>

<div class="pipeline-container" id="pipeline-svg"></div>
</section>

<section>
<h2>Recent Runs</h2>
<div id="runs-container" class="no-data">
  Waiting for token.
</div>
</section>

</article>

<script>
const OWNER = 'atvirokodosprendimai';
const REPO = 'coroot-cicd';
const WORKFLOW = 'coroot-update.yml';

const JOBS_ORDER = [
  'Check for Image Updates',
  'Backup Volumes',
  'Staging Validation',
  'Deploy to Production',
  'Rollback on Failure',
  'Post-Pipeline Cleanup'
];

const JOBS_SHORT = {
  'Check for Image Updates': 'Check Updates',
  'Backup Volumes': 'Backup',
  'Staging Validation': 'Staging',
  'Deploy to Production': 'Deploy',
  'Rollback on Failure': 'Rollback',
  'Post-Pipeline Cleanup': 'Cleanup'
};

// Muted, Tufte-appropriate status colors
const STATUS_COLORS = {
  success: '#4a8c5c',
  completed: '#4a8c5c',
  failure: '#b55555',
  cancelled: '#888888',
  skipped: '#888888',
  in_progress: '#5580aa',
  queued: '#a89040',
  pending: '#a89040',
  waiting: '#a89040',
};

function getToken() { return localStorage.getItem('gh_pat') || ''; }
function saveToken() {
  const t = document.getElementById('token-input').value.trim();
  if (t) { localStorage.setItem('gh_pat', t); document.getElementById('token-input').value = ''; fetchData(); }
}

async function ghFetch(path) {
  const token = getToken();
  if (!token) throw new Error('No token provided');
  const resp = await fetch(`https://api.github.com${path}`, {
    headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/vnd.github+json' }
  });
  if (!resp.ok) throw new Error(`GitHub API ${resp.status}: ${resp.statusText}`);
  return resp.json();
}

let currentRunId = null;
let runsData = [];

async function fetchData() {
  try {
    const data = await ghFetch(`/repos/${OWNER}/${REPO}/actions/workflows/${WORKFLOW}/runs?per_page=10`);
    runsData = data.workflow_runs || [];
    renderRuns();
    if (runsData.length > 0) {
      const run = currentRunId ? runsData.find(r => r.id === currentRunId) || runsData[0] : runsData[0];
      await selectRun(run.id);
    }
    document.getElementById('last-updated').textContent = `Updated ${new Date().toLocaleTimeString()}`;
  } catch (e) {
    document.getElementById('runs-container').innerHTML = `<div class="error-msg">${e.message}</div>`;
  }
}

function renderRuns() {
  const container = document.getElementById('runs-container');
  if (!runsData.length) { container.innerHTML = '<div class="no-data">No workflow runs found.</div>'; return; }
  container.innerHTML = runsData.map(run => {
    const status = run.conclusion || run.status;
    const date = new Date(run.created_at);
    const trigger = run.event === 'schedule' ? 'Scheduled' : run.event === 'workflow_dispatch' ? 'Manual' : run.event;
    return `
      <div class="run-item ${run.id === currentRunId ? 'active' : ''}" onclick="selectRun(${run.id})">
        <span class="status-dot ${status}"></span>
        <div class="run-meta">
          <div class="title">Run #${run.run_number}</div>
          <div class="info">${trigger} &middot; ${date.toLocaleDateString()} ${date.toLocaleTimeString()} &middot;
            <a href="${run.html_url}" target="_blank">view on GitHub</a></div>
        </div>
        <span class="run-status ${status}">${status}</span>
      </div>`;
  }).join('');
}

async function selectRun(runId) {
  currentRunId = runId;
  renderRuns();
  try {
    const data = await ghFetch(`/repos/${OWNER}/${REPO}/actions/runs/${runId}/jobs`);
    renderPipeline(data.jobs || []);
  } catch (e) {
    document.getElementById('pipeline-svg').innerHTML = `<div class="error-msg">${e.message}</div>`;
  }
}

function renderPipeline(jobs) {
  const container = document.getElementById('pipeline-svg');
  container.innerHTML = '';

  const jobMap = {};
  jobs.forEach(j => { jobMap[j.name] = j; });

  const nodes = JOBS_ORDER.map((name, i) => {
    const job = jobMap[name];
    const status = job ? (job.conclusion || job.status) : 'pending';
    const duration = job && job.completed_at && job.started_at
      ? Math.round((new Date(job.completed_at) - new Date(job.started_at)) / 1000) : null;
    return { name, short: JOBS_SHORT[name], status, duration, index: i, job };
  });

  const edges = [[0,1],[1,2],[2,3],[3,4],[3,5],[4,5]];

  const nodeW = 130, nodeH = 52, padX = 36, padY = 24;
  const positions = [
    { x: 0, y: 0 },
    { x: (nodeW + padX), y: 0 },
    { x: 2 * (nodeW + padX), y: 0 },
    { x: 3 * (nodeW + padX), y: 0 },
    { x: 3 * (nodeW + padX), y: nodeH + padY },
    { x: 4 * (nodeW + padX), y: 0 },
  ];

  const svgW = 5 * (nodeW + padX) + 30;
  const svgH = 2 * (nodeH + padY) + 20;
  const offX = 15, offY = 10;

  const svg = d3.select(container).append('svg')
    .attr('viewBox', `0 0 ${svgW} ${svgH}`)
    .attr('height', svgH);

  // Arrow marker
  svg.append('defs').append('marker')
    .attr('id', 'arrow').attr('viewBox', '0 0 10 10')
    .attr('refX', 10).attr('refY', 5)
    .attr('markerWidth', 6).attr('markerHeight', 6)
    .attr('orient', 'auto')
    .append('path').attr('d', 'M 0 0 L 10 5 L 0 10 z').attr('fill', '#999');

  // Draw edges
  edges.forEach(([from, to]) => {
    const src = positions[from], dst = positions[to];
    let x1, y1, x2, y2;

    if (from === 4 && to === 5) {
      x1 = offX + src.x + nodeW; y1 = offY + src.y + nodeH / 2;
      x2 = offX + dst.x; y2 = offY + dst.y + nodeH;
      const midX = offX + dst.x;
      svg.append('path')
        .attr('d', `M ${x1} ${y1} L ${midX} ${y1} L ${midX} ${y2}`)
        .attr('fill', 'none').attr('stroke', '#bbb').attr('stroke-width', 1)
        .attr('marker-end', 'url(#arrow)');
      return;
    }

    if (src.y === dst.y) {
      x1 = offX + src.x + nodeW; y1 = offY + src.y + nodeH / 2;
      x2 = offX + dst.x; y2 = offY + dst.y + nodeH / 2;
    } else if (dst.y > src.y) {
      x1 = offX + src.x + nodeW / 2; y1 = offY + src.y + nodeH;
      x2 = offX + dst.x + nodeW / 2; y2 = offY + dst.y;
    } else {
      x1 = offX + src.x + nodeW / 2; y1 = offY + src.y;
      x2 = offX + dst.x + nodeW / 2; y2 = offY + dst.y + nodeH;
    }

    const isDash = (from === 3 && to === 4); // deploy->rollback is conditional
    svg.append('line')
      .attr('x1', x1).attr('y1', y1).attr('x2', x2).attr('y2', y2)
      .attr('stroke', '#bbb').attr('stroke-width', 1)
      .attr('stroke-dasharray', isDash ? '4,3' : 'none')
      .attr('marker-end', 'url(#arrow)');
  });

  // Draw nodes
  const nodeGroup = svg.selectAll('.pipeline-node').data(nodes).enter()
    .append('g').attr('class', 'pipeline-node')
    .attr('transform', (d, i) => `translate(${offX + positions[i].x}, ${offY + positions[i].y})`)
    .style('cursor', 'pointer')
    .on('click', (event, d) => { if (d.job && d.job.html_url) window.open(d.job.html_url, '_blank'); });

  nodeGroup.append('rect')
    .attr('width', nodeW).attr('height', nodeH)
    .attr('fill', '#fffff8')
    .attr('stroke', d => STATUS_COLORS[d.status] || '#ccc');

  // Small status circle
  nodeGroup.append('circle')
    .attr('cx', 14).attr('cy', nodeH / 2).attr('r', 4)
    .attr('fill', d => STATUS_COLORS[d.status] || '#ccc');

  // Job name
  nodeGroup.append('text')
    .attr('x', 24).attr('y', nodeH / 2 - 3)
    .attr('dominant-baseline', 'middle')
    .text(d => d.short);

  // Duration
  nodeGroup.append('text').attr('class', 'duration')
    .attr('x', 24).attr('y', nodeH / 2 + 13)
    .attr('dominant-baseline', 'middle')
    .text(d => d.duration != null ? `${Math.floor(d.duration / 60)}m ${d.duration % 60}s` : '');

  // Status bar
  const bar = document.getElementById('status-bar');
  const run = runsData.find(r => r.id === currentRunId);
  if (run) {
    const jobSummary = nodes.map(n =>
      `<span><span class="status-dot ${n.status}"></span>${n.short}</span>`
    ).join(' &nbsp; ');
    bar.innerHTML = `<strong>Run #${run.run_number}</strong> &nbsp; ${jobSummary}
      &nbsp; <span id="last-updated" style="color:#888">Updated ${new Date().toLocaleTimeString()}</span>`;
  }
}

// Auto-load
if (getToken()) { document.getElementById('token-input').placeholder = 'Token saved'; fetchData(); }
setInterval(() => { if (getToken()) fetchData(); }, 30000);
</script>
</body>
</html>
